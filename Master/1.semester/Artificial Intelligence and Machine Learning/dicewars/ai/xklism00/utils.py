# File: utils.py
# Solution: SUI - project
# Date: 9.10.2021
# Authors: Jan Lorenc, Michal Kliš, Michal Sova, Jana Gregorová
# Faculty: Faculty of information technology VUT
# Description: Namespace class for helper functions.


from dicewars.ai.utils import *


class Utils:

    @staticmethod
    def order_players(players_order, player_name):
        """ For expectiminimax to work we need the players order from our
            position, not the initial one as we might start anywhere.
            Parameters
            ----------
            players_order :
                Order of players generated by the game.
            player_name :
                Name of the player
            Returns
            -------
            list
                Order of players starting with us
        """
    
        index = players_order.index(player_name)
        return players_order[index:] + players_order[:index]

    @staticmethod
    def get_largest_region(board, player_name):
        """ Gets areas of the player's largest region.
            Parameters
            ----------
            board :
                Instance of a board
            player_name :
                Name of the player
            Returns
            -------
            list
                Areas of the largest region
        """

        all_areas = board.get_player_areas(player_name)
        regions = board.get_players_regions(player_name)
        largest_region_areas_count = max([len(areas) for areas in regions])
        largest_region_area_names = [areas for areas in regions if len(areas) == largest_region_areas_count][0]
        return [area for area in all_areas if area.get_name() in largest_region_area_names]

    @staticmethod
    def get_border_areas(board, player_name):
        """ Gets border areas of the player.
            board :
                Instance of a board
            player_name :
                Name of the player
            Returns
            -------
            list
                Players border areas
        """

        areas = Utils.get_largest_region(board, player_name)
        areas_names = [area.get_name() for area in areas]
        return [area for area in board.get_player_border(player_name) if area.get_name() in areas_names]

    @staticmethod
    def claim_area(board, src_name, dst_name):
        """ Simulates successful attack. Changes area owner and reduces dice in both attacker and defender areas.
            Parameters
            ----------
            board :
                Instance of a board on which the move is being made.
            src_name :
                Name of source area (attacker)
            dst_name :
                Name of destination area (target)
        """

        src = board.get_area(src_name)
        dst = board.get_area(dst_name)
        dst.set_owner(src.get_owner_name())
        dst.set_dice(src.get_dice() - 1)
        src.set_dice(1)

    @staticmethod
    def get_possible_attacks(board, player_name):
        """ Gets possible attacks with sufficient attack and holding success probability.
            Parameters
            ----------
            board :
                Instance of a board.
            player_name :
                Name of the player who is attacking.
            Returns
            -------
            list
                Attacks with their probability scores
        """

        min_prob = 0.55  # we want more than 50% chance to both conquer and defend
        attacks = []
        for src, dst in possible_attacks(board, player_name):
            win_prob = attack_succcess_probability(src.get_dice(), dst.get_dice())
            hold_prob = probability_of_holding_area(board, dst.get_name(), src.get_dice() - 1, player_name)
            if win_prob > min_prob and hold_prob > min_prob or src.get_dice() == 8:
                attacks.append((src, dst, win_prob*hold_prob))

        return attacks

    @staticmethod
    def vectorize_game_state(board, regions):
        """ Creates vector representation of a board.
            There are 34 areas in the game, for each we need owner (34 values), number of dice (34 values),
            and their distribution = neighbors (595 values ... (34*34-34) / 2 - we don't need duplicate information
            or that area neighbors with itself ... no constant in the code, it should work with other config as well).
            In addition, information for each player about how many areas they have (4 values = 4 players) and how many
            of those belong to their biggest region, which is quite important (another 4 values).
            Parameters
            ----------
            board :
                Current board
            regions :
                Vector of length 4 (for each player) with area counts in the largest regions.
                Cannot be computed from board as in server/game is server.board from which we cannot extract the info.
            Returns
            -------
            list
                Integer vector of length 637 (34 + 34 + 595 + 4 + 4).
        """

        areas = list(board.areas.values())
        areas_count = len(areas)
        player_names = range(1, 5)

        area_owners = [name if name else 0 for name in [a.get_owner_name() for a in areas]]  # can be False on none -> 0
        owned_areas = [len([a for a in areas if a.get_owner_name() == p]) for p in player_names]
        dice = [a.get_dice() for a in areas]
        neighbors = []
        for i in range(0, areas_count):
            neigh_areas = areas[i].get_adjacent_areas_names()   # for each area find its neighbors
            for j in range(i + 1, areas_count):                 # only following to avoid duplicates
                neighbors.append(1 if areas[j].get_name() in neigh_areas else 0)

        # it's preferable not to have similar values next to itself (e.g. dice have higher numbers than neighbors)
        return area_owners + owned_areas + neighbors + regions + dice

    @staticmethod
    def transfer_to_border(board, player_name, heuristic):
        """ Takes the weakest border area, its inner neighbor with most dice and returns them for transfer.
            Parameters
            ----------
            board :
                Instance of a board on which it searches for possible transfers.
            player_name :
                Name of the player making transfers.
            heuristic :
                Heuristic class instances with the trained model.
            Returns
            -------
            tuple
                Best possible transfer if any.
        """

        areas = Utils.get_largest_region(board, player_name)
        areas_names = [area.get_name() for area in areas]
        border_areas = [area for area in board.get_player_border(player_name) if area.get_name() in areas_names]
        area_scores = sorted([(a, heuristic.evaluate_transfer_score(board, player_name, a))
                             for a in border_areas if a.get_dice() < 8], key=lambda x: x[1])
        border_names = [area.get_name() for area in border_areas]
        inner_areas = [area for area in areas if area.get_name() not in border_names]

        # it's sorted -> starts with the weakest
        for dst, _ in area_scores:
            neighbor_names = dst.get_adjacent_areas_names()
            inner_neighbors = [a for a in inner_areas if a.get_name() in neighbor_names and a.get_dice() > 1]
            # reverse sorted -> starts with strongest
            for src in sorted(inner_neighbors, key=lambda x: x.get_dice(), reverse=True):
                return src.get_name(), dst.get_name()

        return None

    @staticmethod
    def transfer_from_border(board, player_name, heuristic):
        """ Considers undefendable (holding prob < 0.5) border areas from the largest region and simulates
            all possible dice evacuation transfers to their neighbors. It computes score loss based on the
            holding probability and trained model and selects the transfer that minimizes the loss.
            Parameters
            ----------
            board :
                Instance of a board on which it searches for possible transfers.
            player_name :
                Name of the player making transfers.
            heuristic :
                Heuristic class instances with the trained model.
            Returns
            -------
            tuple
                Best possible transfer if any.
        """

        # transfers can be done only in the largest regions
        areas = Utils.get_largest_region(board, player_name)
        areas_names = [area.get_name() for area in areas]
        # endangered border areas with the ability to save some dice
        border_areas = [a for a in board.get_player_border(player_name)
                        if a.get_name() in areas_names and a.get_dice() > 1
                        and probability_of_holding_area(board, a.get_name(), a.get_dice(), player_name)]

        transfer = None
        max_score = 0
        for src in border_areas:
            neighbors = [board.get_area(a) for a in src.get_adjacent_areas_names() if a in areas_names]
            for dst in neighbors:
                loss_without_transfer = Utils.transfer_from_border_loss(board, player_name, src, dst, heuristic)

                # simulate the transfer
                src_dice, dst_dice = (src.get_dice(), dst.get_dice())
                dice_moved = min(8 - dst_dice, src_dice - 1)
                src.dice -= dice_moved
                dst.dice += dice_moved

                loss_with_transfer = Utils.transfer_from_border_loss(board, player_name, src, dst, heuristic)
                score = loss_without_transfer - loss_with_transfer
                if max_score < score:
                    max_score = score
                    transfer = src.get_name(), dst.get_name()

                # reset from the simulation
                src.set_dice(src_dice)
                dst.set_dice(dst_dice)

        return transfer

    @staticmethod
    def transfer_from_border_loss(board, player_name, src, dst, heuristic):
        """ Loss for evacuation transfers based on holding area probability, heuristic and number of dice.
            Parameters
            ----------
            board :
                Instance of a board.
            player_name :
                Name of the player making transfers.
            src :
                Area making transfer from.
            dst :
                Area making transfer to.
            heuristic :
                Heuristic class instances with the trained model.
            Returns
            -------
            float
                Loss of the configuration.
        """

        inverted_score_src = 1 - heuristic.evaluate_transfer_score(board, player_name, src)
        inverted_score_dst = 1 - heuristic.evaluate_transfer_score(board, player_name, dst)
        return inverted_score_src * src.get_dice() + inverted_score_dst * dst.get_dice()
